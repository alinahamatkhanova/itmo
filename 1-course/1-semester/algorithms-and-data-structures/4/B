#include <iostream>
#include <vector>
using namespace std;

class MinHeap {
private:
    vector<int> num;
    int parent(int idx) {
        return (idx - 1) / 2;
    }
    int leftChild(int idx) {
        return (2 * idx + 1);
    }
    int rightChild(int idx) {
        return (2 * idx + 2);
    }
    void SiftDown(int idx)
    {

        int left = leftChild(idx);
        int right = rightChild(idx);
        int small = idx;

        if (left < Size() && num[left] < num[idx]) {
            small = left;
        }
        if (right < Size() && num[right] < num[small]) {
            small = right;
        }
        if (small != idx) {
            swap(num[idx], num[small]);
            SiftDown(small);
        }
    }

    void SiftUp(int idx) {
        if (idx == 0) return;

        if (num[parent(idx)] > num[idx]) {
            swap(num[idx], num[parent(idx)]);
            SiftUp(parent(idx));
        }
    }

public:
    int Size() {
        return num.size();
    }
    bool Empty() {
        return num.empty();
    }
    void Push(int value) {
        num.push_back(value);
        SiftUp(num.size() - 1);
    }
    void Pop()
    {
        if (num.empty()) return;

        num.front() = num.back();
        num.pop_back();
        SiftDown(0);
    }
    int Top()
    {
        return num.front();
    }

    void DecreasePriority(int old, int now) {
        for (int i = 0; i < num.size(); ++i) {
            if (num[i] == old) {
                num[i] = now;
                SiftUp(i);
                break;
            }
        }
    }
};
int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr);

    vector<MinHeap> min;
    string comm;
    while (cin >> comm) {
        if (comm == "create") {
            min.push_back({});
        }
        else if (comm == "insert") {
            int idx, value;
            cin >> idx >> value;
            min[idx].Push(value);
        }
        else if (comm == "extract-min") {
            int idx; cin >> idx;
            if (min[idx].Size() == 0) {
                cout << '*' << '\n'; continue;
            }
            cout << min[idx].Top() << '\n';
            min[idx].Pop();
        }
        else if (comm == "merge") {
            int idx1, idx2; cin >> idx1 >> idx2;
            MinHeap newMin = min[idx1];
            MinHeap minHeap2 = min[idx2];
            while (!minHeap2.Empty()) {
                newMin.Push(minHeap2.Top());
                minHeap2.Pop();
            }
            min.push_back(newMin);
        }
        else if (comm == "decrease-key") {
            int heap, old, now; cin >> heap >> old >> now;

            if (heap >= min.size()) continue;

            min[heap].DecreasePriority(old, now);
        }
    }
}
